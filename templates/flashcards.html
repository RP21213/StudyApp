<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flashcard Game</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #4f46e5;
            --success-color: #10b981;
            --danger-color: #ef4444;
            --text-main: #1f2937;
            --text-secondary: #6b7280;
            --border-color: #e5e7eb;
            --background-body: #f9fafb;
            --background-card: #ffffff;
            --card-shadow: 0 10px 15px -3px rgba(0,0,0,0.1), 0 4px 6px -2px rgba(0,0,0,0.05);
        }
        body {
            font-family: 'Poppins', sans-serif;
            background-color: var(--background-body);
            margin: 0;
            padding: 2rem;
            color: var(--text-main);
            touch-action: none; /* Prevents scrolling on touch devices */
        }
        .container { max-width: 500px; margin: 0 auto; }
        .game-header { text-align: center; margin-bottom: 1.5rem; }
        .deck-container {
            position: relative;
            width: 100%;
            height: 350px;
            perspective: 1000px;
            margin-bottom: 1.5rem;
        }
        .flashcard {
            position: absolute;
            width: 100%; height: 100%;
            cursor: grab;
            user-select: none;
            transition: transform 0.3s ease, opacity 0.3s ease;
            transform-origin: center;
        }
        .flashcard-inner {
            position: relative; width: 100%; height: 100%;
            text-align: center;
            transition: transform 0.6s;
            transform-style: preserve-3d;
            box-shadow: var(--card-shadow);
            border-radius: 16px;
        }
        .flashcard.is-flipped .flashcard-inner { transform: rotateX(180deg); }
        .flashcard-front, .flashcard-back {
            position: absolute; width: 100%; height: 100%;
            -webkit-backface-visibility: hidden; backface-visibility: hidden;
            border-radius: 16px;
            display: flex; align-items: center; justify-content: center;
            padding: 1.5rem; border: 1px solid var(--border-color);
            box-sizing: border-box;
        }
        .flashcard-front { background-color: var(--background-card); font-size: 1.25rem; font-weight: 600; }
        .flashcard-back { background-color: #f3f4f6; transform: rotateX(180deg); }
        
        .swipe-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            border-radius: 16px; display: flex; align-items: center; justify-content: center;
            font-size: 2rem; font-weight: bold; color: white;
            opacity: 0; transition: opacity 0.2s;
        }
        .swipe-right { background-color: rgba(16, 185, 129, 0.7); }
        .swipe-left { background-color: rgba(239, 68, 68, 0.7); }

        .game-controls { display: flex; justify-content: space-around; align-items: center; }
        .swipe-btn {
            background-color: white; border: 1px solid var(--border-color);
            border-radius: 50%; width: 60px; height: 60px;
            cursor: pointer; display: flex; align-items: center; justify-content: center;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .swipe-btn:hover { transform: scale(1.1); box-shadow: 0 7px 10px rgba(0,0,0,0.1); }
        .swipe-btn svg { width: 28px; height: 28px; }
        #wrong-btn svg { color: var(--danger-color); }
        #correct-btn svg { color: var(--success-color); }

        .results-screen { text-align: center; padding: 2rem; }
        .results-screen h2 { font-size: 2rem; }
        .button { display: inline-flex; text-decoration: none; font-weight: 600; padding: 0.75rem 1.5rem; border-radius: 8px; background: var(--primary-color); color: white; transition: background-color 0.2s; border: none; font-size: 1rem; cursor: pointer; }
        .button:hover { background-color: var(--primary-hover); }
        
        /* Spaced Repetition Styles */
        .mode-toggle {
            display: flex;
            gap: 0.5rem;
            margin: 1rem 0;
            justify-content: center;
        }
        
        .mode-btn {
            padding: 0.75rem 1.5rem;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            background: var(--background-card);
            color: var(--text-secondary);
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .mode-btn.active {
            background: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }
        
        .mode-btn:hover:not(.active) {
            background: var(--background-body);
            color: var(--text-main);
        }
        
        .spaced-stats {
            display: flex;
            justify-content: center;
            gap: 2rem;
            margin: 1rem 0;
            padding: 1rem;
            background: var(--background-card);
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }
        
        .stat-item {
            text-align: center;
        }
        
        .stat-label {
            display: block;
            font-size: 0.875rem;
            color: var(--text-secondary);
            margin-bottom: 0.25rem;
        }
        
        .stat-value {
            display: block;
            font-size: 1.25rem;
            font-weight: 700;
            color: var(--primary-color);
        }
        
        /* Spaced Repetition Rating Buttons */
        .spaced-rating-buttons {
            display: none;
            gap: 1rem;
            justify-content: center;
            margin-top: 1rem;
        }
        
        .spaced-rating-btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            min-width: 100px;
        }
        
        .spaced-rating-btn.again {
            background: var(--danger-color);
            color: white;
        }
        
        .spaced-rating-btn.hard {
            background: #f59e0b;
            color: white;
        }
        
        .spaced-rating-btn.good {
            background: var(--success-color);
            color: white;
        }
        
        .spaced-rating-btn.easy {
            background: var(--primary-color);
            color: white;
        }
        
        .spaced-rating-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

    </style>
</head>
<body>
    <div class="container">
        <div class="game-header">
            <h1 id="game-title">{{ activity.title or 'Flashcard Set' }}</h1>
            <p id="game-subtitle">Click card to flip. Swipe or use buttons to answer.</p>
            
            <!-- Spaced Repetition Mode Toggle -->
            <div class="mode-toggle">
                <button id="regular-mode-btn" class="mode-btn active" onclick="switchMode('regular')">
                    <span>ðŸŽ® Regular Mode</span>
                </button>
                <button id="spaced-mode-btn" class="mode-btn" onclick="switchMode('spaced')">
                    <span>ðŸ§  Spaced Repetition</span>
                </button>
            </div>
            
            <!-- Spaced Repetition Stats -->
            <div id="spaced-stats" class="spaced-stats" style="display: none;">
                <div class="stat-item">
                    <span class="stat-label">Due Cards:</span>
                    <span class="stat-value" id="due-count">0</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Total Cards:</span>
                    <span class="stat-value" id="total-count">0</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Accuracy:</span>
                    <span class="stat-value" id="accuracy-display">0%</span>
                </div>
            </div>
        </div>

        <div class="deck-container" id="deck-container">
            {% for card in activity.data.cards %}
            <div class="flashcard" data-index="{{ loop.index0 }}">
                <div class="flashcard-inner">
                    <div class="flashcard-front">
                        <div class="swipe-overlay swipe-right">KNEW IT</div>
                        <div class="swipe-overlay swipe-left">DON'T KNOW</div>
                        <p>{{ card.front }}</p>
                    </div>
                    <div class="flashcard-back">
                        <p>{{ card.back }}</p>
                    </div>
                </div>
            </div>
            {% endfor %}
            <div class="results-screen" style="display: none;">
                <h2>Session Complete!</h2>
                <p>You reviewed all the cards in this deck.</p>
                <p><strong>Correct:</strong> <span id="correct-count">0</span> | <strong>Incorrect:</strong> <span id="incorrect-count">0</span></p>
                <div style="display: flex; gap: 1rem; justify-content: center; margin-top: 1rem;">
                    <button id="save-exit-btn" class="button">Save & Exit to Hub</button>
                    <button id="back-to-dashboard-btn" class="button" style="background: var(--text-secondary);">Back to Dashboard</button>
                </div>
            </div>
        </div>

        <div class="game-controls" id="game-controls">
            <button class="swipe-btn" id="wrong-btn" title="I don't know">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" /></svg>
            </button>
            <button class="swipe-btn" id="correct-btn" title="I know this">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M4.5 12.75l6 6 9-13.5" /></svg>
            </button>
        </div>
        
        <!-- Spaced Repetition Rating Buttons -->
        <div class="spaced-rating-buttons" id="spaced-rating-buttons">
            <button class="spaced-rating-btn again" onclick="rateCardSpaced(0)">
                <span>Again</span>
                <small>0-1 days</small>
            </button>
            <button class="spaced-rating-btn hard" onclick="rateCardSpaced(1)">
                <span>Hard</span>
                <small>1 day</small>
            </button>
            <button class="spaced-rating-btn good" onclick="rateCardSpaced(2)">
                <span>Good</span>
                <small>1+ days</small>
            </button>
            <button class="spaced-rating-btn easy" onclick="rateCardSpaced(3)">
                <span>Easy</span>
                <small>4+ days</small>
            </button>
        </div>
    </div>
    
    <script>
    const deckContainer = document.getElementById('deck-container');
    const allCards = Array.from(deckContainer.querySelectorAll('.flashcard'));
    const resultsScreen = deckContainer.querySelector('.results-screen');
    const correctCountEl = document.getElementById('correct-count');
    const incorrectCountEl = document.getElementById('incorrect-count');
    const saveExitBtn = document.getElementById('save-exit-btn');
    const gameControls = document.getElementById('game-controls');
    const activityId = '{{ activity.id }}';
    const hubId = '{{ activity.hub_id }}';
    
    let currentCard = null;
    let isDragging = false;
    let startX = 0;
    let offsetX = 0;
    
    const results = { correct: [], incorrect: [] };

    function setupCards() {
        allCards.forEach((card, index) => {
            card.style.zIndex = allCards.length - index;
            card.style.transform = `translateY(${index * 4}px) scale(${1 - (index * 0.05)})`;
            card.addEventListener('click', () => card.classList.toggle('is-flipped'));

            // Mouse Events
            card.addEventListener('mousedown', startDrag);
            // Touch Events
            card.addEventListener('touchstart', startDrag);
        });
        
        document.addEventListener('mouseup', endDrag);
        document.addEventListener('touchend', endDrag);
        document.addEventListener('mousemove', drag);
        document.addEventListener('touchmove', drag);
        
        document.getElementById('wrong-btn').onclick = () => swipeCard('left');
        document.getElementById('correct-btn').onclick = () => swipeCard('right');
        saveExitBtn.onclick = saveAndExit;
        
        // Add event listener for back to dashboard button
        const backToDashboardBtn = document.getElementById('back-to-dashboard-btn');
        if (backToDashboardBtn) {
            backToDashboardBtn.onclick = () => {
                window.location.href = '/dashboard';
            };
        }
    }
    
    function updateTopCard() {
        const topCard = deckContainer.querySelector('.flashcard:not(.swiped)');
        currentCard = topCard || null;
    }

    function startDrag(e) {
        updateTopCard();
        if (!currentCard) return;
        
        isDragging = true;
        startX = e.pageX || e.touches[0].pageX;
        currentCard.style.transition = 'none'; // Disable transition while dragging
    }

    function drag(e) {
        if (!isDragging || !currentCard) return;
        e.preventDefault();
        
        const currentX = e.pageX || e.touches[0].pageX;
        offsetX = currentX - startX;
        
        const rotation = offsetX / 20; // Rotate card as it's dragged
        currentCard.style.transform = `translateX(${offsetX}px) rotate(${rotation}deg)`;
        
        const rightOverlay = currentCard.querySelector('.swipe-right');
        const leftOverlay = currentCard.querySelector('.swipe-left');

        rightOverlay.style.opacity = Math.max(0, offsetX / 100);
        leftOverlay.style.opacity = Math.max(0, -offsetX / 100);
    }
    
    function endDrag() {
        if (!isDragging || !currentCard) return;
        isDragging = false;
        
        const swipeThreshold = 100;
        
        if (offsetX > swipeThreshold) {
            swipeCard('right');
        } else if (offsetX < -swipeThreshold) {
            swipeCard('left');
        } else {
            // Return to center if not swiped far enough
            currentCard.style.transition = 'transform 0.3s ease';
            currentCard.style.transform = '';
            const overlays = currentCard.querySelectorAll('.swipe-overlay');
            overlays.forEach(o => o.style.opacity = '0');
        }
        offsetX = 0;
    }

    function swipeCard(direction) {
        updateTopCard();
        if (!currentCard) return;

        const cardIndex = parseInt(currentCard.dataset.index);
        const flyoutX = direction === 'right' ? 500 : -500;
        
        if (direction === 'right') {
            results.correct.push(cardIndex);
        } else {
            results.incorrect.push(cardIndex);
        }
        
        currentCard.style.transition = 'transform 0.5s ease, opacity 0.5s ease';
        currentCard.style.transform = `translateX(${flyoutX}px) rotate(${flyoutX/20}deg)`;
        currentCard.style.opacity = '0';
        currentCard.classList.add('swiped');
        
        updateDeck();
    }

    // âœ… UPDATED FUNCTION
    function updateDeck() {
         const remainingCards = allCards.filter(c => !c.classList.contains('swiped'));
         
         if (remainingCards.length === 0) {
             showResults();
             return; // Stop the function after showing results
         }

         // This new block of code loops through the remaining cards 
         // and resets their size and position in the stack.
         remainingCards.forEach((card, index) => {
            card.style.transition = 'transform 0.3s ease, opacity 0.3s ease';
            card.style.zIndex = remainingCards.length - index;
            // The new top card (at index 0) will animate to full size (scale(1))
            card.style.transform = `translateY(${index * 4}px) scale(${1 - (index * 0.05)})`;
        });
    }
    
    function showResults() {
        gameControls.style.display = 'none';
        resultsScreen.style.display = 'block';
        correctCountEl.textContent = results.correct.length;
        incorrectCountEl.textContent = results.incorrect.length;
    }

    async function saveAndExit() {
        saveExitBtn.textContent = 'Saving...';
        saveExitBtn.disabled = true;

        try {
            await fetch(`/flashcards/${activityId}/save_game`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(results)
            });
        } catch (error) {
            console.error('Failed to save results:', error);
        } finally {
            window.location.href = `/hub/${hubId}`;
        }
    }

    // Spaced Repetition Variables
    let currentMode = 'regular';
    let spacedCards = [];
    let currentSpacedCardIndex = 0;
    let spacedStats = { correct: 0, incorrect: 0, total: 0 };
    let currentSessionId = null;
    
    // Mode switching functions
    async function switchMode(mode) {
        currentMode = mode;
        
        // Update button states
        document.getElementById('regular-mode-btn').classList.toggle('active', mode === 'regular');
        document.getElementById('spaced-mode-btn').classList.toggle('active', mode === 'spaced');
        
        // Show/hide appropriate UI elements
        document.getElementById('game-controls').style.display = mode === 'regular' ? 'flex' : 'none';
        document.getElementById('spaced-rating-buttons').style.display = mode === 'spaced' ? 'flex' : 'none';
        document.getElementById('spaced-stats').style.display = mode === 'spaced' ? 'flex' : 'none';
        
        if (mode === 'spaced') {
            await loadSpacedRepetitionData();
        } else {
            // Complete current session if switching away from spaced repetition
            if (currentMode === 'spaced' && currentSessionId) {
                await completeSpacedRepetitionSession();
            }
            // Reset to regular mode
            resetToRegularMode();
        }
    }
    
    async function loadSpacedRepetitionData() {
        try {
            const response = await fetch(`/api/spaced_repetition/enhanced_flashcards/${activityId}`);
            const data = await response.json();
            
            if (data.success) {
                spacedCards = data.cards;
                currentSpacedCardIndex = 0;
                spacedStats = { correct: 0, incorrect: 0, total: 0 };
                
                // Update stats display with null checks
                const dueCountEl = document.getElementById('due-count');
                const totalCountEl = document.getElementById('total-count');
                const accuracyEl = document.getElementById('accuracy-display');
                
                if (dueCountEl) dueCountEl.textContent = data.due_cards;
                if (totalCountEl) totalCountEl.textContent = data.total_cards;
                if (accuracyEl) accuracyEl.textContent = '0%';
                
                // Create a spaced repetition session
                await createSpacedRepetitionSession();
                
                // Load first card
                if (spacedCards.length > 0) {
                    loadSpacedCard();
                } else {
                    alert('No spaced repetition cards available. Please ensure flashcards are properly migrated.');
                    switchMode('regular');
                }
            } else {
                console.error('Failed to load spaced repetition data:', data.message);
                alert('Failed to load spaced repetition data: ' + data.message);
                switchMode('regular');
            }
        } catch (error) {
            console.error('Error loading spaced repetition data:', error);
            alert('An error occurred while loading spaced repetition data');
            switchMode('regular');
        }
    }
    
    async function createSpacedRepetitionSession() {
        try {
            const response = await fetch('/api/spaced_repetition/create_session', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    hub_id: hubId,
                    session_type: 'spaced_repetition',
                    max_cards: spacedCards.length
                })
            });
            
            const data = await response.json();
            if (data.success) {
                currentSessionId = data.session_id;
                console.log('Created spaced repetition session:', currentSessionId);
            } else {
                console.error('Failed to create session:', data.message);
            }
        } catch (error) {
            console.error('Error creating spaced repetition session:', error);
        }
    }
    
    async function completeSpacedRepetitionSession() {
        if (!currentSessionId) {
            console.log('No active session to complete');
            return;
        }
        
        try {
            const response = await fetch('/api/spaced_repetition/complete_session', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    session_id: currentSessionId
                })
            });
            
            const data = await response.json();
            if (data.success) {
                console.log('Completed spaced repetition session:', currentSessionId);
                currentSessionId = null;
            } else {
                console.error('Failed to complete session:', data.message);
            }
        } catch (error) {
            console.error('Error completing spaced repetition session:', error);
        }
    }
    
    function loadSpacedCard() {
        if (currentSpacedCardIndex >= spacedCards.length) {
            showSpacedResults();
            return;
        }
        
        const card = spacedCards[currentSpacedCardIndex];
        if (!card) {
            console.error('No card found at index:', currentSpacedCardIndex);
            return;
        }
        
        // Use the first card element for all spaced repetition cards
        const cardElement = allCards[0];
        if (!cardElement) {
            console.error('No card element found');
            return;
        }
        
        // Update card content with null checks
        const frontElement = cardElement.querySelector('.flashcard-front p');
        const backElement = cardElement.querySelector('.flashcard-back p');
        
        if (frontElement) frontElement.textContent = card.front || '';
        if (backElement) backElement.textContent = card.back || '';
        
        // Reset card state
        cardElement.classList.remove('is-flipped');
        
        // Show only the first card (we'll reuse it for all spaced repetition cards)
        allCards.forEach((c, index) => {
            if (c) {
                if (index === 0) {
                    c.style.display = 'block';
                    c.style.zIndex = 1;
                } else {
                    c.style.display = 'none';
                }
            }
        });
    }
    
    async function rateCardSpaced(rating) {
        try {
            // Validate that we have cards and current card exists
            if (!spacedCards || spacedCards.length === 0) {
                console.error('No spaced cards available');
                alert('No cards available for rating');
                return;
            }
            
            if (currentSpacedCardIndex >= spacedCards.length) {
                console.error('Current card index out of bounds');
                alert('No more cards to rate');
                return;
            }
            
            const card = spacedCards[currentSpacedCardIndex];
            if (!card || !card.id) {
                console.error('Invalid card data:', card);
                alert('Invalid card data');
                return;
            }
            
            // Update local stats
            if (rating >= 2) {
                spacedStats.correct++;
            } else {
                spacedStats.incorrect++;
            }
            spacedStats.total++;
            
            // Send rating to server
            const response = await fetch('/api/spaced_repetition/review_card', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    card_id: card.id,
                    quality_rating: rating
                })
            });
            
            const data = await response.json();
            
            if (data.success) {
                // Update accuracy display with null check
                const accuracy = Math.round((spacedStats.correct / spacedStats.total) * 100);
                const accuracyEl = document.getElementById('accuracy-display');
                if (accuracyEl) accuracyEl.textContent = accuracy + '%';
                
                // Move to next card
                currentSpacedCardIndex++;
                
                if (currentSpacedCardIndex < spacedCards.length) {
                    setTimeout(() => {
                        loadSpacedCard();
                    }, 500);
                } else {
                    showSpacedResults();
                }
            } else {
                console.error('Failed to save rating:', data.message);
                alert('Failed to save rating: ' + data.message);
            }
        } catch (error) {
            console.error('Error rating card:', error);
            alert('An error occurred while saving your rating');
        }
    }
    
    function showSpacedResults() {
        // Hide card and rating buttons with null checks
        const deckContainer = document.getElementById('deck-container');
        const ratingButtons = document.getElementById('spaced-rating-buttons');
        const statsContainer = document.getElementById('spaced-stats');
        
        if (deckContainer) deckContainer.style.display = 'none';
        if (ratingButtons) ratingButtons.style.display = 'none';
        
        // Show results
        const accuracy = Math.round((spacedStats.correct / spacedStats.total) * 100);
        
        if (statsContainer) {
            statsContainer.innerHTML = `
                <div class="stat-item">
                    <span class="stat-label">Session Complete!</span>
                    <span class="stat-value">${spacedStats.total} cards reviewed</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Accuracy</span>
                    <span class="stat-value">${accuracy}%</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Correct</span>
                    <span class="stat-value">${spacedStats.correct}</span>
                </div>
            `;
            
            // Add restart button
            const restartBtn = document.createElement('button');
            restartBtn.className = 'button';
            restartBtn.textContent = 'Start New Session';
            restartBtn.onclick = async () => {
                await completeSpacedRepetitionSession();
                currentSpacedCardIndex = 0;
                spacedStats = { correct: 0, incorrect: 0, total: 0 };
                if (deckContainer) deckContainer.style.display = 'block';
                loadSpacedRepetitionData();
            };
            
            // Add back to dashboard button
            const dashboardBtn = document.createElement('button');
            dashboardBtn.className = 'button';
            dashboardBtn.textContent = 'Back to Dashboard';
            dashboardBtn.style.background = 'var(--text-secondary)';
            dashboardBtn.style.marginLeft = '1rem';
            dashboardBtn.onclick = async () => {
                await completeSpacedRepetitionSession();
                window.location.href = '/dashboard';
            };
            
            // Create button container
            const buttonContainer = document.createElement('div');
            buttonContainer.style.display = 'flex';
            buttonContainer.style.gap = '1rem';
            buttonContainer.style.justifyContent = 'center';
            buttonContainer.style.marginTop = '1rem';
            
            buttonContainer.appendChild(restartBtn);
            buttonContainer.appendChild(dashboardBtn);
            statsContainer.appendChild(buttonContainer);
        }
    }
    
    function resetToRegularMode() {
        // Reset all cards to original state with null checks
        if (allCards && allCards.length > 0) {
            allCards.forEach((card, index) => {
                if (card) {
                    card.style.display = 'block';
                    card.style.zIndex = allCards.length - index;
                    card.style.transform = `translateY(${index * 4}px) scale(${1 - (index * 0.05)})`;
                    card.classList.remove('is-flipped');
                }
            });
        }
        
        // Reset stats
        spacedStats = { correct: 0, incorrect: 0, total: 0 };
        currentSpacedCardIndex = 0;
    }

    setupCards();
    </script>
</body>
</html>